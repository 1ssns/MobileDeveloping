**Задание 4**  
Попробуем создать свою функцию высокого порядка и одновременно функцию расширения.

1. Опишите функцию filterAndMap.
2. Эта функция должна быть функцией расширения класса Array<Int>. Ознакомиться с понятием функций расширения можно в методических указаниях.
3. Наша функция filterAndMap должна принимать как входящие параметры две следующие функции (параметра) – filter с типом (Int) -> Boolean и map с типом (Int) -> Int.
4. Выходящий параметр нашей функции – целочисленный массив.
5. Функция расширения представляет собой «расширение» для какого-то класса. Далее она может вызываться как функция, которая как будто бы существует в этом классе. В функции расширения мы можем обратиться к экземпляру этого классе через ключевое слово this. Используя это ключевое слово, обратитесь к целочисленному массиву, и вызовите у него функции filter (передавая переменную filter), следом вызовите функцию map (передавая переменную map).
6. Вся эта цепочка вызовов будет возвращаемым значением нашей функции filterAndMap. Чтобы все точно заработало, последней функцией в цепочке вызовите toTypedArray()
7. Мы получили функцию высокого порядка, потому что она принимает другие функции на вход. Можете попробовать использовать ее в коде, вызывая как обычно через точку для целочисленного массива. В качестве входящих параметров можно использовать task1 и task2 лямбды.
8. Как думаете, какой принцип SOLID мы нарушили, написав такую функцию? Вопрос можно оставить без ответа.  
   **Ответ: ну тут можно сказать, что мы нарушили принцип единой ответственности, т.к. наша функция расширения выполняет два действия: фильтрует и маппит**
